package akka.rtcweb.protocol.dtls.handshake

import java.security.SecureRandom

import akka.rtcweb.protocol.DoNotExport
import akka.rtcweb.protocol.dtls._
import scodec._
import scodec.bits._
import codecs._


/**
 * 4 byte
 */
case class SessionId(raw: ByteVector) {
  require(raw.length <= 4, "must be <= 4 bytes")
}

object SessionId {
  implicit val codec = "SessionId" | bytes(4).as[SessionId]
  implicit val optionCodec = "Option[SessionId]" | optional(recover(constant(ByteVector.low(4))), bytes(4).as[SessionId])
}

/**
 *
 * @param gmtUnixTime uint32 The current time and date in standard UNIX 32-bit format
 * (seconds since the midnight starting Jan 1, 1970, UTC, ignoring
 * leap seconds) according to the sender's internal clock.  Clocks
 * are not required to be set correctly by the basic TLS protocol;
 * higher-level or application protocols may define additional
 * requirements.  Note that, for historical reasons, the data
 * element is named using GMT, the predecessor of the current
 * worldwide time base, UTC.
 * @param randomBytes 28 bytes generated by a secure random number generator.
 */
case class Random(
  gmtUnixTime: Long,
  randomBytes: ByteVector)

object Random {

  implicit val codec = "Random" | {
    ("gmtUnixTime" | uint32) ::
      ("random_bytes" | bytes(28))
  }.as[Random]

  private val secureRandom: SecureRandom = new SecureRandom()

  @inline private def generate(size: Int): Array[Byte] = {
    val bytes = new Array[Byte](size)
    secureRandom.nextBytes(bytes)
    bytes
  }

  def make: Random = Random(System.currentTimeMillis() / 1000L, ByteVector(generate(28)))

}

sealed trait HandshakeType

object HandshakeType {
  case object hello_request extends HandshakeType //(0)
  case object client_hello extends HandshakeType //(1)
  case object server_hello extends HandshakeType //(2)

  /**
   * This one is DTLS specific
   */
  case object hello_verify_request extends HandshakeType //(3)
  case object certificate extends HandshakeType //(11)
  case object server_key_exchange extends HandshakeType //(12)
  case object certificate_request extends HandshakeType //(13)
  case object server_hello_done extends HandshakeType //(14)
  case object certificate_verify extends HandshakeType //(15)
  case object client_key_exchange extends HandshakeType //(16)
  case object finished extends HandshakeType //(20)

  implicit val codec: Codec[HandshakeType] = "HandshakeType" | mappedEnum(uint8,
    hello_request -> 0,
    client_hello -> 1,
    server_hello -> 2,
    hello_verify_request -> 3,
    certificate -> 11,
    server_key_exchange -> 12,
    certificate_request -> 13,
    server_hello_done -> 14,
    certificate_verify -> 15,
    client_key_exchange -> 16,
    finished -> 20)

}

/**
 * {{{
 * struct {
 *  HandshakeType msg_type;
 *  uint24 length;
 *  uint16 message_seq;                               // New field
 *  uint24 fragment_offset;                           // New field
 *  uint24 fragment_length;                           // New field
 *  select (HandshakeType) {
 *    case hello_request: HelloRequest;
 *    case client_hello:  ClientHello;
 *    case hello_verify_request: HelloVerifyRequest;  // New type
 *    case server_hello:  ServerHello;
 *    case certificate:Certificate;
 *    case server_key_exchange: ServerKeyExchange;
 *    case certificate_request: CertificateRequest;
 *    case server_hello_done:ServerHelloDone;
 *    case certificate_verify:  CertificateVerify;
 *    case client_key_exchange: ClientKeyExchange;
 *    case finished: Finished;
 *  } body;
 * } Handshake;
 * }}}
 */
sealed class Handshake(handshakeType: HandshakeType)

sealed trait HandshakeBody

case class Cookie(raw: ByteVector)
object Cookie {
  implicit val codec = variableSizeBytes(uint8, bytes).as[Cookie]
}

case class HelloVerifyRequest(
  serverVersion: ProtocolVersion,
  cookie: Cookie) extends HandshakeBody

object HelloVerifyRequest {
  implicit val codec = "HelloVerifyRequest" | {
    ("server_version" | ProtocolVersion.codec) ::
      ("cookie" | Cookie.codec)
  }.as[HelloVerifyRequest]
}

/**
 * The server will send this message in response to a ClientHello
 * message when it was able to find an acceptable set of algorithms.
 * If it cannot find such a match, it will respond with a handshake
 * failure alert.
 */
case class ServerHello(
  serverVersion: ProtocolVersion,
  random: Random,
  sessionId: SessionId,
  cipherSuite: CipherSuite,
  compressionMethod: CompressionMethod,
  extensions: List[Extension]) extends HandshakeBody

object ServerHello {

  /**
   * {{{
   * struct {
   *   ProtocolVersion server_version;
   *   Random random;
   *   SessionID session_id;
   *   CipherSuite cipher_suite;
   *   CompressionMethod compression_method;
   *   select (extensions_present) {
   *     case false:
   *      struct {};
   *     case true:};
   *      Extension extensions<0..2^16-1>;
   *
   * } ServerHello;
   * }}}
   */
  implicit val codec = "ServerHello" | {
    ("server_version" | ProtocolVersion.codec) ::
      ("random" | Random.codec) ::
      ("session_id" | SessionId.codec) ::
      ("cipher_suite" | CipherSuite.codec) ::
      ("compression_method" | CompressionMethod.codec) ::
      ("extensions" | listOfN(uint16, Extension.codec))
  }.as[ServerHello]
}

/**
 *  When a client first connects to a server, it is required to send
 * the ClientHello as its first message.  The client can also send a
 * ClientHello in response to a HelloRequest or on its own initiative
 * in order to renegotiate the security parameters in an existing
 * connection.
 *
 * @param clientVersion The version of the TLS protocol by which the client wishes to
 * communicate during this session.  This SHOULD be the latest
 * (highest valued) version supported by the client.  For this
 * version of the specification, the version will be 3.3 (see
 * Appendix E for details about backward compatibility).
 * @param random A client-generated random structure.
 *
 * @param sessionId The ID of a session the client wishes to use for this connection.
 * This field is empty if no session_id is available, or if the
 * client wishes to generate new security parameters.
 * @param cipherSuites This is a list of the cryptographic options supported by the
 * client, with the client's first preference first.  If the
 * session_id field is not empty (implying a session resumption
 * request), this vector MUST include at least the cipher_suite from
 * that session.  Values are defined in Appendix A.5.
 * @param compressionMethods This is a list of the compression methods supported by the client,
 * sorted by client preference.  If the session_id field is not empty
 * (implying a session resumption request), it MUST include the compression_method from that session.  This vector MUST contain,
 * and all implementations MUST support, CompressionMethod.null.
 * Thus, a client and server will always be able to agree on a
 * compression method.
 * @param extensions Variable length, 0..2&#94;16-1. Clients MAY request extended functionality from servers by sending
 * data in the extensions field.  The actual "Extension" format is
 * defined in Section 7.4.1.4.
 */
case class ClientHello(
  clientVersion: ProtocolVersion,
  random: Random,
  sessionId: Option[SessionId],
  cookie: Cookie,
  cipherSuites: List[CipherSuite],
  compressionMethods: List[CompressionMethod],
  extensions: List[Extension])

object ClientHello {

  implicit val cookie = "ClientHello" | {
    ("client_version" | ProtocolVersion.codec) ::
      ("random" | Random.codec) ::
      ("session_id" | SessionId.optionCodec) ::
      ("cookie" | Cookie.codec) ::
      ("cipher_suites" | listOfN(uint8, CipherSuite.codec)) ::
      ("compression_methods" | listOfN(uint8, CompressionMethod.codec)) ::
      ("extensions" | listOfN(uint8, Extension.codec))
  }.as[ClientHello]

}

/**
 *
 * A Finished message is always sent immediately after a change
 * cipher spec message to verify that the key exchange and
 * authentication processes were successful.  It is essential that a
 * change cipher spec message be received between the other handshake
 * messages and the Finished message.
 *
 * The Finished message is the first one protected with the just
 * negotiated algorithms, keys, and secrets.  Recipients of Finished
 * messages MUST verify that the contents are correct.  Once a side
 * has sent its Finished message and received and validated the
 * Finished message from its peer, it may begin to send and receive
 * application data over the connection.
 *
 * Structure of this message:
 * {{{
 * struct {
 *   opaque verify_data[verify_data_length];
 * } Finished;
 *
 * verify_data
 *   PRF(master_secret, finished_label, Hash(handshake_messages))
 * [0..verify_data_length-1];
 *
 * finished_label
 * }}}
 * For Finished messages sent by the client, the string
 * "client finished".  For Finished messages sent by the server,
 * the string "server finished".
 *
 * Hash denotes a Hash of the handshake messages.  For the PRF
 * defined in Section 5, the Hash MUST be the Hash used as the basis
 * for the PRF.  Any cipher suite which defines a different PRF MUST
 * also define the Hash to use in the Finished computation.
 *
 * In previous versions of TLS, the verify_data was always 12 octets
 * long.  In the current version of TLS, it depends on the cipher
 * suite.  Any cipher suite which does not explicitly specify
 * verify_data_length has a verify_data_length equal to 12.  This
 * includes all existing cipher suites.  Note that this
 * representation has the same encoding as with previous versions.
 * Future cipher suites MAY specify other lengths but such length
 * MUST be at least 12 bytes.
 * @param verifyData
 */
case class HandshakeFinished(verifyData: ByteVector) extends HandshakeBody

object HandshakeFinished {
  /**
   *  In previous versions of TLS, the verify_data was always 12 octets
   * long.  In the current version of TLS, it depends on the cipher
   * suite.  Any cipher suite which does not explicitly specify
   * verify_data_length has a verify_data_length equal to 12.  This
   * includes all existing cipher suites.  Note that this
   * representation has the same encoding as with previous versions.
   * Future cipher suites MAY specify other lengths but such length
   * MUST be at least 12 bytes.
   */
  implicit val codec = "HandshakeFinished" | { bytes(12).as[HandshakeFinished] }
}

object ServerHelloDone extends HandshakeBody {
  implicit val codec:Codec[ServerHelloDone.type] = "ServerHelloDone" | provide(ServerHelloDone)
}

object ClientHelloDone extends HandshakeBody {
  implicit val codec:Codec[ClientHelloDone.type] = "ClientHelloDone" | provide(ClientHelloDone)
}

/**
 * The HelloRequest message MAY be sent by the server at any time.
 *
 *  HelloRequest is a simple notification that the client should begin
 * the negotiation process anew.  In response, the client should send
 * a ClientHello message when convenient.  This message is not
 * intended to establish which side is the client or server but
 * merely to initiate a new negotiation.  Servers SHOULD NOT send a
 * HelloRequest immediately upon the client's initial connection.  It
 * is the client's job to send a ClientHello at that time.
 *
 * This message will be ignored by the client if the client is
 * currently negotiating a session.  This message MAY be ignored by
 * the client if it does not wish to renegotiate a session, or the
 * client may, if it wishes, respond with a no_renegotiation alert.
 * Since handshake messages are intended to have transmission
 * precedence over application data, it is expected that the
 * negotiation will begin before no more than a few records are
 * received from the client.  If the server sends a HelloRequest but
 * does not receive a ClientHello in response, it may close the
 * connection with a fatal alert.
 */
object HelloRequest extends HandshakeBody {
  implicit val codec:Codec[HelloRequest.type ] = "HelloRequest" | provide(HelloRequest)
}

/**
 *  This message is always sent by the client.  It MUST immediately
 * follow the client certificate message, if it is sent.  Otherwise,
 * it MUST be the first message sent by the client after it receives
 * the ServerHelloDone message.
 *
 * With this message, the premaster secret is set, either by direct
 * transmission of the RSA-encrypted secret or by the transmission of
 * Diffie-Hellman parameters that will allow each side to agree upon
 * the same premaster secret.
 *
 *
 * When the client is using an ephemeral Diffie-Hellman exponent,
 * then this message contains the client's Diffie-Hellman public
 * value.  If the client is sending a certificate containing a static
 * DH exponent (i.e., it is doing fixed_dh client authentication),
 * then this message MUST be sent but MUST be empty.
 *
 * Structure of this message:
 *
 * The choice of messages depends on which key exchange method has
 * been selected.  See Section 7.4.3 for the KeyExchangeAlgorithm
 * definition.
 *
 * {{{
 *   struct {
 *     select (KeyExchangeAlgorithm) {
 *       case rsa:
 *        EncryptedPreMasterSecret;
 *       case dhe_dss:
 *       case dhe_rsa:
 *       case dh_dss:
 *       case dh_rsa:
 *       case dh_anon:
 *        ClientDiffieHellmanPublic;
 *    } exchange_keys;
 *  } ClientKeyExchange;
 * }}}
 *
 */
sealed trait ClientKeyExchange

case class RsaClientKeyExchange(exchangeKeys: EncryptedPreMasterSecret) extends ClientKeyExchange

object RsaClientKeyExchange {
  implicit val codec = "RsaClientKeyExchange" | {
    "exchange_keys" | EncryptedPreMasterSecret.codec
  }.as[RsaClientKeyExchange]
}

//todo: continue
case object DhClientKeyExchange extends ClientKeyExchange

/**
 * {{{
 * struct {
 * ProtocolVersion client_version;
 * opaque random[46];
 * } PreMasterSecret;
 * }}}
 * @param clientVersion The latest (newest) version supported by the client.  This is
 * used to detect version rollback attacks.
 * @param random 46 securely-generated random bytes.
 *
 */
case class PreMasterSecret(
  clientVersion: ProtocolVersion,
  random: ByteVector)

object PreMasterSecret {
  implicit val codec = "PreMasterSecret" | {
    ("client_version" | ProtocolVersion.codec) ::
      ("random" | bytes(48))
  }.as[PreMasterSecret]
}

/**
 * This structure conveys the client's Diffie-Hellman public value
 * (Yc) if it was not already included in the client's certificate.
 * The encoding used for Yc is determined by the enumerated
 * PublicValueEncoding.  This structure is a variant of the client
 * key exchange message, and not a message in itself.
 */
@DoNotExport
sealed trait PublicValueEncoding

object PublicValueEncoding {

  /**
   * If the client has sent a certificate which contains a suitable
   * Diffie-Hellman key (for fixed_dh client authentication), then
   * Yc is implicit and does not need to be sent again.  In this
   * case, the client key exchange message will be sent, but it MUST
   * be empty.
   */
  case object `implicit` extends PublicValueEncoding

  /**
   * Yc needs to be sent.
   */
  case object explicit extends PublicValueEncoding
}

/**
 * {{{
 *   struct {
 * public-key-encrypted PreMasterSecret pre_master_secret;
 * } EncryptedPreMasterSecret;
 * }}}
 */
case class EncryptedPreMasterSecret(preMasterSecret: PreMasterSecret)

object EncryptedPreMasterSecret {
  implicit val codec = "EncryptedPreMasterSecret" | {
    "preMasterSecret" | PreMasterSecret.codec
  }.as[EncryptedPreMasterSecret]
}